import inspect
import os
import pathlib
import sys
import typing
import re

import numpy as np
import pandas as pd
import psutil  # type: ignore
from IPython.core.getipython import get_ipython
from numpy.typing import NDArray

import multiprocessing as mp
from tqdm.notebook import tqdm


# from tqdm import tqdm


def export(function):
    module_globals = inspect.stack()[1][0].f_globals
    if "__all__" not in module_globals:
        module_globals["__all__"] = []

    module_globals["__all__"].append(function.__name__)
    # print(function.__name__, module_globals["__name__"], module_globals["__all__"])

    return function


def load_slope_values(path: str) -> tuple[int, NDArray]:
    data = np.load(path)

    return data[0], data[1:]


def get_memory() -> float:
    """Return memory usage in MB"""
    process = psutil.Process(os.getpid())
    memory_usage = process.memory_info().rss  # in bytes
    return memory_usage / (1024**2)


def is_notebook() -> bool:
    try:
        # Check if the environment is an IPython shell (which includes Jupyter)
        if "ipykernel" in sys.modules or "IPython" in sys.modules:
            if get_ipython().__class__.__name__ == "ZMQInteractiveShell":
                # We're in a Jupyter notebook
                return True
        return False
    except NameError:
        return False  # If 'IPython' is not available, we're not in a notebook


def get_system_params_from_name(name: str) -> dict[str, typing.Any]:
    """

    Get the system parameters from the folder name generated by SandpileND.run_multiple_samples
    function.

    :param name: name of the folder
    :return: Dictionary of the system parameters
    """

    values = name.split("_")

    result = dict()
    result["dimension"] = int(values[0][1:])
    result["linear_grid_size"] = int(values[1][1:])
    result["critical_slope"] = int(values[2][1:])

    if values[3] == "op":
        result["boundary_condition"] = "open"
    elif values[3] == "cl":
        result["boundary_condition"] = "closed"
    else:
        raise ValueError(f"unknown boundary condition {values[3]}")

    if values[4] == "co":
        result["perturbation"] = "conservative"
    elif values[4] == "nco":
        result["perturbation"] = "non conservative"
    else:
        raise ValueError(f"unknown perturbation {values[4]}")

    return result


def get_short_params(dct: dict[str, typing.Any]) -> dict[str, typing.Any]:
    val = dct["boundary_condition"]
    dct["boundary_condition"] = "op" if val == "open" else "cl"

    val = dct["perturbation"]
    dct["perturbation"] = "co" if val == "conservative" else "nco"

    return dct


def load_combine_avalanche_data_samples(
    data_dir: str | pathlib.Path, with_dissipation: bool = False, sample_count: int | None = None
) -> pd.DataFrame:
    if isinstance(data_dir, str):
        data_dir = pathlib.Path(data_dir)
    elif not isinstance(data_dir, pathlib.Path):
        raise TypeError("data_dir must be pathlib.Path or str")

    df = pd.DataFrame({})
    files = data_dir.glob("*.avalanche.csv")
    for i, file in enumerate(files):
        if sample_count is not None and i == sample_count:
            break
        dfn = pd.read_csv(file)
        dfn["sample"] = int(re.findall(r"\d+", file.name)[0])
        df = pd.concat([df, dfn], axis=0)

    dp_rates = []
    if with_dissipation:
        for i, file in enumerate(files):
            if sample_count is not None and i == sample_count:
                break
            data = np.load(file)
            dp_rates.extend([data[f"arr_{i}"] for i in range(len(data))])

        df["dissipation_rate"] = dp_rates

    df.index.name = "index"
    return df.reset_index().set_index(["sample", "index"])


def load_dissipation_rates(data_dir: str | pathlib.Path) -> list[list[NDArray[np.int8]]]:
    if isinstance(data_dir, str):
        data_dir = pathlib.Path(data_dir)

    it = list(data_dir.glob("*.avalanche.npz"))

    # TODO not working in terminals, only notebooks
    with mp.Pool(mp.cpu_count() - 2) as p:
        p: mp.Pool
        dissipation_rates = list(tqdm(p.imap_unordered(_load_file, it), total=len(it)))

    return dissipation_rates


def _load_file(file) -> list[NDArray[np.uint8]]:
    data = np.load(file)
    return list(data.values())
